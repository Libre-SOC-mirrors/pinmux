# ================================== Steps to add peripherals ============
# Step-1:   create interface declaration for the peripheral to be added.
#           Remember these are interfaces defined for the pinmux and hence
#           will be opposite to those defined at the peripheral.
#           For eg. the output TX from the UART will be input (method Action)
#           for the pinmux.
#           These changes will have to be done in interface_decl.py
# Step-2    define the wires that will be required to transfer data from the
#           peripheral interface to the IO cell and vice-versa. Create a
#           mkDWire for each input/output between the peripheral and the
#           pinmux. Also create an implicit wire of GenericIOType for each cell
#           that can be connected to a each bit from the peripheral.
#           These changes will have to be done in wire_def.py
# Step-3:   create the definitions for each of the methods defined above.
#           These changes will have to be done in interface_decl.py
# ========================================================================

# default module imports
import os
import sys
import time
import math

# project module imports
from interface_decl import *
from interface_def import *
from parse import *
from wire_def import *
from actual_pinmux import *

if not os.path.exists("bsv_src"):
    os.makedirs("bsv_src")

bsv_file = open("./bsv_src/pinmux.bsv", "w")


header = '''
/*
   This BSV file has been generated by the PinMux tool available at:
   https://bitbucket.org/casl/pinmux.

   Authors: Neel Gala, Luke
   Date of generation: ''' + time.strftime("%c") + '''
*/
package pinmux;

   typedef struct{
      Bit#(1) outputval;      // output from core to pad                bit7
      Bit#(1) output_en;      // output enable from core to pad         bit6
      Bit#(1) input_en;       // input enable from core to io_cell      bit5
      Bit#(1) pullup_en;      // pullup enable from core to io_cell     bit4
      Bit#(1) pulldown_en;    // pulldown enable from core to io_cell   bit3
      Bit#(1) drivestrength;  // drivestrength from core to io_cell     bit2
      Bit#(1) pushpull_en;    // pushpull enable from core to io_cell   bit1
      Bit#(1) opendrain_en;   // opendrain enable form core to io_cell  bit0
   } GenericIOType deriving(Eq,Bits,FShow);

   interface Ifc_pinmux;
'''
footer = '''
   endmodule
endpackage
'''
# ============================================#
# ==== populating the file with the code =====#
# ============================================#

# package and interface declaration followed by the generic io_cell definition
bsv_file.write(header)

bsv_file.write('''

      // declare the method which will capture the user pin-mux
      // selection values.The width of the input is dependent on the number
      // of muxes happening per IO. For now we have a generalized width
      // where each IO will have the same number of muxes.''')

for cell in muxed_cells:
    bsv_file.write(mux_interface.format(cell[0],
                                        int(math.log(len(cell) - 1, 2))))

bsv_file.write('''

      // declare the interface to the IO cells.
      // Each IO cell will have 8 input field (output from pin mux
      // and on output field (input to pinmux)''')
for i in range(0, N_IO):
    bsv_file.write('''\n      // interface for IO CEll-{0}''')
    bsv_file.write(io_interface.format(i))
# ==============================================================

# == create method definitions for all peripheral interfaces ==#
for i in range(0, N_UART):
    bsv_file.write('''
      // interface declaration between UART-{0} and pinmux'''.format(i))
    bsv_file.write(uartinterface_decl.format(i))

for i in range(0, N_SPI):
    bsv_file.write('''
      // interface declaration between SPI-{0} and pinmux'''.format(i))
    bsv_file.write(spiinterface_decl.format(i))

for i in range(0, N_TWI):
    bsv_file.write('''
      // interface declaration between TWI-{0} and pinmux'''.format(i))
    bsv_file.write(twiinterface_decl.format(i))

for i in range(0, N_SD):
    bsv_file.write('''
      // interface declaration between SD-{0} and pinmux'''.format(i))
    bsv_file.write(sdinterface_decl.format(i))

for i in range(0, N_JTAG):
    bsv_file.write('''
      // interface declaration between JTAG-{0} and pinmux'''.format(i))
    bsv_file.write(jtaginterface_decl.format(i))
# ==============================================================

# ===== finish interface definition and start module definition=======
bsv_file.write('''
   endinterface
   (*synthesize*)
   module mkpinmux(Ifc_pinmux);
''')
# ====================================================================

# ======================= create wire and registers =================#
bsv_file.write('''
      // the followins wires capture the pin-mux selection
      // values for each mux assigned to a CELL
''')
for cell in muxed_cells:
    bsv_file.write(muxwire.format(cell[0], int(math.log(len(cell) - 1, 2))))


bsv_file.write(
    '''\n      // following wires capture the values sent to the IO Cell''')
for i in range(0, N_IO):
    bsv_file.write(generic_io.format(i))

for i in range(0, N_UART):
    bsv_file.write(
        '''\n      // following wires capture signals to IO CELL if uart-{0} is
      // allotted to it'''.format(i))
    bsv_file.write(uartwires.format(i))

for i in range(0, N_SPI):
    bsv_file.write(
        '''\n      // following wires capture signals to IO CELL if spi-{0} is
      // allotted to it'''.format(i))
    bsv_file.write(spiwires.format(i))

for i in range(0, N_TWI):
    bsv_file.write(
        '''\n      // following wires capture signals to IO CELL if twi-{0} is
      // allotted to it'''.format(i))
    bsv_file.write(twiwires.format(i))

for i in range(0, N_SD):
    bsv_file.write(
        '''\n      // following wires capture signals to IO CELL if sd-{0} is
      // allotted to it'''.format(i))
    bsv_file.write(sdwires.format(i))

for i in range(0, N_JTAG):
    bsv_file.write(
        '''\n      // following wires capture signals to IO CELL if jtag-{0} is
      // allotted to it'''.format(i))
    bsv_file.write(jtagwires.format(i))
bsv_file.write("\n")
# ====================================================================
# ========================= Actual pinmuxing ========================#
bsv_file.write('''
      /*====== This where the muxing starts for each io-cell======*/
''')
bsv_file.write(pinmux)
bsv_file.write('''
      /*============================================================*/
''')
# ====================================================================
# ================= interface definitions for each method =============#
for cell in muxed_cells:
    bsv_file.write(mux_interface_def.format(cell[0],
                                            int(math.log(len(cell) - 1, 2))))
for i in range(0, N_IO):
    bsv_file.write(io_interface_def.format(i))
for i in range(0, N_UART):
    bsv_file.write(uartinterface_def.format(i))
for i in range(0, N_SPI):
    bsv_file.write(spiinterface_def.format(i))
for i in range(0, N_TWI):
    bsv_file.write(twiinterface_def.format(i))
for i in range(0, N_SD):
    bsv_file.write(sdinterface_def.format(i))
for i in range(0, N_JTAG):
    bsv_file.write(jtaginterface_def.format(i))
bsv_file.write(footer)
print("BSV file successfully generated: bsv_src/pinmux.bsv")
# ======================================================================
bsv_file.close()
